### JS补充

#### 1.兼容性问题之透明度

------

(1)普通浏览器使用opacity:0.5;

(2)兼容ie8浏览器使用filter:alpha(opacity=50);

代码：

```xml
<style>
    /* 设置透明 */
        opacity: 0.5;
        /* 兼容ie8浏览器 */
        filter: alpha(opacity=50);
</style>
```
#### 2.事件冒泡

------

JS中当触发某些具有冒泡性质的事件是，首先在触发元素寻找是否有相应的注册事件，如果没有再继续向上级父元素寻找是否有相应的注册事件作出相应，这就是事件冒泡。

#### 3.事件委托

------

利用事件冒泡的特性，将本应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现其本身没有相应事件就到父元素上寻找作出相应。这样做的优势有：1.减少DOM操作，提高性能。2.随时可以添加子元素，添加的子元素会自动有相应的处理事件。

注意：

事件处理时每个子节点对应不同的事件，就需要获得节点：Event对象提供了一个属性叫target，可以返回事件的目标节点，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置。

代码：

<script>
        var oUl = document.getElementById("ul1");
        oUl.onclick = function (ev) {
            var ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            if (target.nodeName.toLowerCase() == 'li') {
                alert(123);
                alert(target.innerHTML);
            }
        }
    </script>
#### 4.类的操作

------

一行代码，可以同时修改多个样式---->修改元素box的class属性来间接修改样式，浏览器只需要渲染页面一次，并且这种方式，可以使表现和行为进一步分离。

代码：

```html
<script>
	box.className="b2";
</script>
```

#### 5.JSON

------

（1）JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转化为任意语言的对象，JSON在开发中主要用来数据的交互,属性名必须为双引号。

（2) - JavaScript object Notation Js对象表示法

（3）JSON分类：

​				#对象{}

​				#数组[]

（4）将JSON的字符串转换为Js中的对象

​				#在js中为我们提供了一个工具类，就叫JSON，是我们可以把字符串转化为JSON，也可以把JSON转化为字符串。

<script>
    //json-->js对象
    //JSON.parse()
    //           --它需要一个JSON字符串作为参数
    var o= JSON.parse(json);
    console.log(o.name);

```html
//js对象-->JSON
//JSON.stringify()
//         --它需要一个Js对象作为参数
 var str= JSON.stringify(obj);
console.log(str);

//JSON这个对象在ie7及以下的浏览器中不支持，调用会报错
//如果使用eval()执行的字符串中含有{}，它会将{}当成是代码块
//如果不希望将其当作代码块解析，则需要在字符串前后各加一个（）
//eval():尽量不要使用，安全性能差
//          --这个函数可以用来执行一段字符串形式的JS代码，并返回执行结果
//如果真要考虑浏览器兼容，引入外部包
var obj=eval("("+str+")");
```

</script>

### CSS小操作

(1)下边框：border-bottom

(2)下右圆角： border-bottom-right-radius

(3)间隙： text-indent: 2rem;

(3)背景： background: url("") no-repeat center center;

(4)手掌： cursor: pointer;

(3)拖拽：resize: none;

(4)选中边框，取消颜色：outline:none

(5)图片是精灵图标的话：background:url("") no-repeat  0 0;   background-position:0 -17px;

(6)颜色线性渐变：linear-gradient(#E55C3D,#C50000);

(7)清空输入框内容：$.(#inpu).val("");

### JS高级

#### 1.数据类型

------

（1）基本数据类型：String，Number, boolean,undefined,null

  (2)	对象（引用）类型 ： object,Function,Array

#### 2.类型判断

------

（1）typeof（返回数据类型字符串；可以判断undefined/数值/字符串/布尔类型, <u>不能判断null,object  ==object与arr==ay</u>）

<script>
    var b1={
        b2=[1,2,3,4,5];
    }
    //类型判断
    consol.log(typeof(b1.b2)); //返回的是object,而不是array
</script>

（2）instanceof（判断对象的具体类型）

（3）===(可以判断null，undefined)

#### 3.面试题(1)

------

(1)null和undefined的区别

答：null是定义了赋值为null，undefined是定义了未初始化。

​		null的返回类型为object,undefined返回类型是object

(2)什么时候变量赋值为null

答：表明将要初始化为对象。最后释放内存也可以使用b=null（让b指向的对象断开，使之成为垃圾对象，利于回收）

(3)严格区分变量类型和数据类型

答：变量类型（变量内存值的类型），基本类型：保存的就是基本类型的数据，引用类型：保存的是地址值。

#### 4.数据变量内存

------

（1）数据：存储在内存中代表特定的信息，本质上010101.....

​		特点：数据的传递：可传递，可运算

（2）变量：可变化的量，由变量名和变量值组成；每个变量都对应一块小地址

（3）内存：内部存储的数据，地址值；内存分类：栈：全局变量/局部变量  堆：对象

（4）内存，数据，变量三者之间的关系：内存用来存储数据的空间；变量是内存的标识

#### 5.引用变量赋值的问题

------

（1）2个引用变量指向同一个对象，通过一个变量修改对象内部数据，其他所有变量看到的是修改之后的数据。

<script>
    var obj1={name:'tom'};
    var obj2=obj1;
    obj2.age=12;
    console.log(obj1.age);//12
</script>

（2）2个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象。

<script>
    var a={age:12};
    var b=a;
    a={name:'BOB',age=13};
    b.age=14;
    console.log(b.age,a.name,a.age)//14 BOB 13
    //函数
    function fn2(obj){
        obj={age:15};
    };
    fn2(a);
    console.log(a.age);//13
</script>

 (3)   在js调用函数时传递变量参数时，理解1：是值（基本值/地址值）传递。

理解2：可能是值传递，也可能是引用类型（地址值）传递。

（4）JS引擎如何管理内存，释放内存？

答：局部变量：函数执行完自动释放；对象：成为垃圾对象==>垃圾回收器回收

#### 6.对象

------

（1）多个数据的封装体，用来保存多个数据的容器，一个对象代表现实中的一个事物。

（2）组成：属性：属性名（字符串）和属性值（任意）组成；方法：一种特别的属性，属性值是函数

（3）实现：.属性名（编码简单，适用于一般的调用）和['属性名']（编码复杂，通用）；

   		#什么时候必须使用['属性名']的方式？ 1.属性名包含特殊字符：- 空格

​			2.属性名不确定

#### 7.函数

------

  （1）实现特定功能的n条语句的封装体；提高代码复用

  （2）如何调用函数：test():直接调用；obj.test():通过对象调用； new test():new 调用； ==test.call//apply(obj)==：临时让成为obj的方法进行调用。

##### 7.1回调函数

------

（1）定义的，没有调，但最终他执行了，定时器回调函数

​			#ajax请求回调函数	#生命周期回调函数

##### 7.2IIEF

------

全称：Immediately-Invoked Function Expression（立即执行函数）

作用：隐藏实现；不会污染全局作用域

例如：

<script>
    (function(){ //匿名函数自调用
        console.log("111");
    })()
</script>
##### 7.3函数中的this

------

（1）任何函数本质上都是通过某个对象来调用的，如果没有直接指定的就是window

（2）所有函数内部都有一个变量this

（3）它的值是调用函数的当前对象

（4）test():window；p.test():p；new test():新创建的对象；p.call(obj):obj

#### 8.函数中的prototype（原型对象）

------

(1)每个函数都有个prototype属性，它默认指向一个Object空对象（即称位：原型对象）

(2)原型对象中有一个属性constuctor,它指向函数对象

(3)函数中的所有实例对象自动拥有原型中的属性。

##### 8.1显示原型与隐式原型

------

（1）每个函数function都有一个prototype,即显示原型（属性），它默认指向一个Object空对象

（2）每个实例对象都有一个__proto__,可称为隐式原型（属性）

（3）对象的隐式原型的值为其对应构造函数的显示原型的值

<img src="E:\扬州前端\学习笔记图片缓存区\image-20201030100843308.png" alt="image-20201030100843308"  />

##### 8.2原型链

------

（1）访问一个对象的属性时，先在自身属性中查找，找到返回

（2）如果没有，再沿着__proto__这条链向上查找，找到返回

（3）如果最终没找到，返回undefined

（4）==本质==：隐式原型链--查找对象属性的方法

注意：==实例对象的隐式类型指向构造函数的显示类型==

![image-20201030104730917](E:\扬州前端\学习笔记图片缓存区\image-20201030104730917.png)

##### 8.3构造函数/原型/实例对象的关系（图解）

![image-20201030112332562](E:\扬州前端\学习笔记图片缓存区\image-20201030112332562.png)

##### 8.4构造函数/原型/实例对象的关系（图解2）

<img src="E:\扬州前端\学习笔记图片缓存区\image-20201102095158852.png" alt="image-20201102095158852"  />

（1）函数的显示原型指向的对象默认的是空的Object实例对象（但Object不满足）

	<script>
	    console.log(Fn.prototype instanceof Object) //true
	    console.log(Object.prototype instanceof Object) //false
	    console.log(Function.prototype instanceof Object) 
	</script>
(2)所有函数都是Function的实例（包含Function）

<script>
    console.log(Function.__proto__ === Function.prototype) 
</script>

(3)Object的原型对象是原型链的尽头

<script>
    console.log(Object.prototype.__proto__)//null 
</script>

##### 8.5原型继承

------

（1）构造函数的实例对象自动拥有构造函数原型对象的属性（方法）

（2）利用的就是原型链

##### 8.6 instanceof

------

（1）表达式：A instanceof B

（2）如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false。《script

```html
<script>
    console.log(Object instanceof Object); //true
</script>
```
（3）Function是通过new自己产生的实例

##### 8.7变量声明提升

------

（1）==通过var定义（声明）的变量==，在定义语句之前就可以访问到，值undefined

<script>
    var a=3;
    function fn(){
        console.log(a);
        var a=4;
    }
    fn(); //undefined ,先去找fun(),变量提升
</script>

##### 8.8函数声明提升

------

（1）通过function声明的函数，在之前就可以直接调用，值函数定义（对象）

==注意：==变量提升的优先级大于函数提升的优先级。

##### 8.9执行上下文

------

图解：![image-20201102113540813](E:\扬州前端\学习笔记图片缓存区\image-20201102113540813.png)

##### 8.10执行上下文栈，后进先出

------

![image-20201102145721860](E:\扬州前端\学习笔记图片缓存区\image-20201102145721860.png)

//结果运行30

(2)结构图：堆栈操作

<img src="E:\扬州前端\学习笔记图片缓存区\image-20201102151154618.png" alt="image-20201102151154618" style="zoom:100%;" />

##### 8.11面试题

------

(1)

<script>
    console.log('gb:'+i); 
    var i=1;
    foo(1);
    function foo(i){
        if(i==4){
            return
        }
        console.log('fb:'+i);
        foo(i+1);//递归调用：在函数内部调用自己
        console.log('fe:'+i);
    }
    console.log("ge:"+i);
</script>

输出：undefined , fb:1,  fb:2, fb:3,销毁：fe:3 ,fe:2 ,fe:1 ;ge:1

执行上下文：5个，window,foo(1),foo(2),foo(3),foo(4)

(2)

<script>
    var c=1;       //实际上var c;
    function c(c){
        console.log(c);
        var c=3;
    }
    //c=1;
    c(2) // 报错，c(2)没有被定义
</script>

(3) 先执行变量提升，再执行函数提升

<script>
    function a(){};
    var a;
    console.log(typeof a) //'function'
</script>

#### 9.作用域与作用域链

------

作用域：作用：隔离变量，不同作用域下同名的变量不会冲突 （变量作用域，函数作用域）

作用域链：在嵌套的作用域中，由下向上（从内到外的）

##### 9.1面试题

<script>
        var a=10;
        function fn(){
            console.log(a);
        }
        function show(){
            var a=20;
            fn();
        }
        show();
    </script>  

答案：10，作用域

 <script>
        var fn=function(){
            console.log(fn);
        }
        fn();
</script>

答案：fn这个函数。

<script>
       var obj ={
            fn2:function(){
                console.log(fn2);
            }
        }
        obj.fn2();
</script>

答案：报错，fn2() is not defined ,作用域的问题，函数体内作用域找不到fn2

#### 10.闭包

##### 10.1循环遍历加监听

<script>
    for(var i =0,length=btns.length;i<length;i++){ //btns伪数组
        var btn=btns[i];
        //将btn所对应的下标保存在btn上
        btn.index=i;
        btn.onclick=function(){
            alert('第'+(this.index+1)+'个')
        }
    }
</script>
//闭包产生的次数是外部函数调用的次数

<script>
    for(var i =0,length=btns.length;i<length;i++){ //btns伪数组
       (function(i){
           var btn=btns[i]
           btn.onclick=function(){
               alert('第'+(i+1)+'个')
           }
       })(i);
    }
</script>

</script>

##### 10.2闭包

------

（1）如何产生一个闭包？

​		答：当一个嵌套内容（子）函数引用了嵌套的外部（父）函数的变量（函数时），就产生了闭包。

（2）闭包到底是什么？

​		答：使用chrome调试查看：理解一：闭包是嵌套的内部函数（绝大部分人）；理解2：包含被引用变量（函数）的对象（极少数人)

==注意==：	闭包存在于嵌套的内部函数中

（3）产生的条件

​		答：函数嵌套；内部函数引用了外部函数的数据（变量/函数）

##### 10.3常见的闭包

------

（1）将函数作为另一个函数的返回值

<script>
    fuction fn1(){
        //此时闭包就已经产生了（函数提升，内部函数对象已经创建了）
        var a=2;
        function fn2(){
            a++;
            console.log(a);
        }
        return fn2;
    }
    var f=fn1()   //引用指向闭包
    f(); //3
    f(); //4
</script>

（2）将函数作为实参传递给另外一个函数调用

<script>
    function showDelay(msg,time){
        setTimeout(function(){ //闭包
            alert(msg);
        },time)
    }
    showDelay('atguigu',200);
</script>

##### 10.4作用

------

（1）使用函数内部的变量在函数执行完后，仍然存活在内存中（ 延长了局部变量的生命周期）

（2）让函数外部可以操作（读写）到函数内部的数据（变量/函数）

##### 10.5闭包的运用2

------

定义Js模块：

* 具有特定功能的js文件

* 将所有的数据和功能都封装在一个函数内部（私有的）

* 只向外暴露一个包含n个方法的对象或函数

* 模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能

  <script>
      function moudle(){
          //私有数据
          var msg="yqs";
          //操作数据的函数
          function dosomething(){
              console.log("dosomething()"+msg.toUpperCase());
          }
          function doOtherthing(){
              console.log("doOtherthing()"+msg.toLowCase());
          }
          //向外暴露对象（给外部使用的方法）
          //调用一个
          return doOtherthing;
          //方法一,调用多个
          return {
              dosomething:dosomething;
              doOtherthing:doOtherthing;
          }
  </script>

  <script>
      //方法2，匿名函数自调用
      (function(window){
          //向外暴露的对象,利用window对象
          window.myMoule2={
               dosomething:dosomething;
               doOtherthing:doOtherthing;
          }
      })(window);
  </script>

  （2）调用者

  ​		方法一的调用：

  ```html
  <script>
  	var myMoule1=moudle();
       myMoule1.dosomething();
       myMoule1.doOtherthing();
  </script>
  ```
  ​		方法2的调用：

  <script>
      myModule2.DoSomething;
      myModule2.DoOtherthing;
  </script>

##### 10.6闭包的缺点和解决

------

缺点

（1）函数执行完后，函数内的局部变量没有释放，占用内存时间会变长。

（2）容易造成内存泄漏

* 解决

（1）能不用闭包就不用

（2）及时释放

##### 10.7内存溢出和内存泄漏

------

内存溢出

（1）一种程序运行时出现的错误

（2）当程序运行需要的内存超过了剩余的内存时，就出现抛出内存溢出的错误

* 内存泄漏

（1）占用的内存没有及时释放

（2）内存泄漏积累多了就容易导致内存溢出

（3）常见的内存泄漏

​		*意外的全局变量

​	   #没有及时清理的计时器或回调函数

​       # 闭包

##### 10.8面试题

------

<script>
    var name="the gril";
    var object={
        name:"my gril",
        getNameFunc:function(){
            return function(){
                //this指向的window
                return this.name;
        };
    }
};
alert(object.getNameFunc()()) // the gril
</script>

(2)

<script>
    var name="the gril";
    var object={
        name:"my gril",
        getNameFunc:function(){
            //this闭包调用
             var that=this;
        return function(){
            //this指向的直接调用者
            return that.name;
    	};
	}
};
alert(object.getNameFunc()()) // my gril
</script>
#### 11. 对象的创建模式

（1）Object构造函数模式：new Object();

（2）对象字面量：var p ={name:"BOB" }

（3）工厂模式：通过工厂函数动态创建并返回 。function creat(name,age){ var obj={name:name, age:age}} 

（4）自定义构造函数模式：通过new来创建对象

（5）构造函数+原型的组合模式：自定义构造函数，属性在函数中初始化，方法添加在原型上。					function Person(){	this.name=name;  }

#### 12.原型链的继承

(1)==关键==：子类型的原型为父类型的一个实例对象。

<script>
    //父类型
    function Supper(){
        this.supProp="Supper";
    }
    Supper.prototype.showSupper=function(){};
    //子类型
    function sub(){
        this.supProp="Sub";
    }
    sub.prototype.showsub=function(){};
    //继承
    sub.prototype=new Supper();
    //使用上述继承后，sub的constructor指向Supper()
    sub.prototype.constructor=sub;
    //使用方法,调用父类的方法
	var s=new sub();
	s.showSupper();
</script>

如图：

![image-20201103160309226](E:\扬州前端\学习笔记图片缓存区\image-20201103160309226.png)

(2)调用构造函数继承（假的）

	<script>
	    function Student(name,age,price){
	        Person.call(this,name,age) //为了得到属性
	        this.price=price;
	    }
	    Student.prototype=new Person() //为了能看到父类方法
	</script>
#### 13.进程和线程

（1）进程：程序的一次执行，它占有一片独有的内存空间；可以通过windows任务管理器查看进程。

（2）线程：是进程内的一个独立的执行单元；是程序执行的一个完整流程；是CPU的最小的调度单元。Js单线程

#### 14.浏览器内核

（1）支撑浏览器运行的核心程序；

（2）不同浏览器可能不一样：![image-20201103172516049](E:\扬州前端\学习笔记图片缓存区\image-20201103172516049.png)

（3）![image-20201103173306591](E:\扬州前端\学习笔记图片缓存区\image-20201103173306591.png)

#### 15.定时器引发的思考

（1）定时器并不能保证真正的定时执行，一般会延迟一点，也可能延迟很长时间。

#### 16.Js是单线程执行

（1）alert() //暂停当前主线程的执行，同时暂停计时后，点击确定后，恢复程序执行和计时。

（2）怎么证明：

​		#setTimeout()的回调函数是在主线程执行的

​		#定时器回调函数只有在运行栈中的代码全部执行完后才可能执行

（3）Js为什么使用单线程

​		#作为浏览器的脚本语言，javaScript的主要用途是与用户互动，以及操作Dom

（4）js引擎执行代码的基本操作

​		#先执行==初始化代码==：包含一些特别的代码  回调函数（异步执行）

​		#设置定时器； 绑定事件监听； 发送ajax请求；后面在某个时刻才会执行回调

![image-20201104111757801](E:\扬州前端\学习笔记图片缓存区\image-20201104111757801.png)

#### 17.Web workers

（1）HTML5的新特性多线程的解决方案，计算量大的教由分线程执行，规范了js分线程的实现

（2）相关Api

​		#Worker:构造函数，加载分线程的js代码

（3）不足：

​		#不能跨域加载Js

​		#worker内代码不能访问Dom(更新)

​		#不是每个浏览器都能使用

例如：

```html
<script>
        // 创建一个Worker对象
        var worker = new Worker('./worker.js');
        // 绑定接受消息监听,主线程接收分线程返回的数据
        worker.onmessage=function(event){
            console.log(event.data);
        }
        // 向分线程发送消息
        worker.postMessage(number);
	</script>		
```
### JQuery基础

#### 1.属性和属性节点

------

（1）属性：就是对象身上的节点，可以通过点语法添加属性。

<img src="https://upload-images.jianshu.io/upload_images/647982-d31bfc904163474f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1192/format/webp" alt="img" style="zoom: 50%;" />

（2）属性节点：在html中编写的所有标签，里面的属性都是属性节点

例如：<span class="box" nj="666"></span>  //class和nj就是属性节点

<img src="https://upload-images.jianshu.io/upload_images/647982-7035a4affa5465ad.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom: 50%;" />

##### 1.1attr和prop方法

（1）attr():用于获取和设置属性节点的值，可以传1个参数，2个参数。删除的话直接使用removeAttr();

例如：

```html
<script>
        $(function () {
            // 1.传1个参数，获取指定属性节点值
            var $res = $(".span1").attr("nj");       
            // 2.传2个参数，设置属性节点
            $(".span1").attr("nj", "666");
        });
</script>
```

（2）prop():用于获取和设置属性的值,删除的话直接使用removeProp();

```xml
//设置属性时,会设置所有找到元素的属性
  $("span").prop("demo", "lnj");
```

##### 1.2.两者区别

- 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()
- 既然所有的DOM对象，都有一个attributes属性,而prop可以操作属性,所以也可以操作属性节点

#### 2.操作类相关的方法

------

（1）addclass(): 给元素添加一个或多个类

（2）removeClass(): 删除元素的一个或多个类

  (3)   toggleClass()：添加或删除一个类(存在就删除不存在就添加)

```html
<script>
        $(function () {
            $("button").eq(2).click(function () {
                // 7.切换一个类
//                $("div").toggleClass("class2");
                // 8.切换多个类
                $("div").toggleClass("class1 class2");
            });
        });
    </script>
```

#### 3.文本值的操作方法

------

（1）html(" ")：添加或获取元素中的HTML，有代码片段就添加，没有参数就是获取。跟原生js中的innerHTML()一样。

例如：添加：$("div").html("<p>我是p标签</p>");

（2）text()：添加或获取元素中的文本，跟原生js的innerText()一样

注意：text方法能做的html方法都能做,所以一般使用html方法即可

例如：添加：$("div").text('我是文本');

（3）val()：添加或获取元素value属性的值，有参数就是添加，没参数就是获取。跟原生js的.value方法一样。

例如：添加： $("input").val("我是一个输入框");

#### 4.操作样式CSS的方法

------

（1）css()：用于设置或获取元素CSS样式  //单个设置 //链式设置  //批量设置

<script>
    // 3.传入对象一次性设置样式 (批量设置最适合)
                $("div").css({
                   "width":"100px",
                    "height":"100px",
                    "background":"blue"
                });
                // 4.获取指定样式的值
                console.log($("div").css("width"));
</script>

#### 5.操作元素尺寸和位置

------

（1）width()：设置或获取元素宽度(相当于获取width属性值)

例如：

```xml
// 1.获取元素宽度(不包括padding和border)
                alert($('.son').width());
 // 2.设置元素宽度(不包括padding和border)
               $(".son").width("50px");
```

（2）offset()：取或设置元素相对窗口的偏移位

例如：

```xml
// 1.获取距离窗口的偏移位(从border开始)
                alert($('.son').offset().left); // 100
// 2.设置距离窗口的偏移位
                $('.son').offset({left:10, top:10});
```

（3）position()：获取相对于它最近的具有相对位置(position:relative或position:absolute)的父级元素的距离，不能进行设置。

例如：

```xml
 // 1.获取匹配元素相对父元素的偏移
		alert($('.son').position().left);// 50
```

（4）scrollTop()：设置或获取匹配元素相对滚动条顶部的偏移

例如：

```xml
// 获取匹配元素相对滚动条顶部的偏移
//           alert($('.scroll').scrollTop());
//		页面滚动条的偏移，ie不兼容
			alert($('html').scrollTop());
// 		兼容所有浏览器写法
             alert($('html').scrollTop()+$('body').scrollTop());

// 设置匹配元素相对滚动条顶部的偏移
//                $('.scroll').scrollTop(100);
//                $('html').scrollTop(100);
      // 兼容所有浏览器写法
                $('html,body').scrollTop(100);
```

#### 6.事件

##### 6.1事件的绑定

------

（1）eventName(function(){})：绑定对应事件名的监听，可以多次绑定，而且还不会覆盖

例如：$('#div').click(function(){})

（2）==on==(eventName, funcion(){})：通用的绑定事件监听 ，可以多次绑定，而且还不会覆盖

例如：$('#div').on('click', function(){});

优缺点:

- eventName: 编码方便, 但有的事件监听不支持
- on: 编码不方便, 但更通用

##### 6.2事件的移除

------

==off==(eventName,function)：移除事件

例如：

```html
// 1.1不传入任何参数,移除所有事件
           $(".son").off();
            // 传入一个参数,移除指定事件
           $(".son").off("click");
            // 传入两个参数,移除指定事件中的指定回调
           $(".son").off("click", box1);
```

##### 6.3事件冒泡和默认行为

------

（1）事件冒泡：从目标元素逐级向上传播到根节点的过程 ：儿子-->父亲-->爷爷

（2)  如何阻止事件冒泡：触发一个元素的事件处理程序时，不影响它的父元素, 此时便可以使用停止事件冒泡 ，可以使用==event.stopPropagation();==

例如：

```html
<script>
	$(".son").click(function (event) {
                console.log(".son");
                // 在子元素中停止事件冒泡,时间不会继续向上传播,所以父元素click方法不会被触发
                event.stopPropagation();
    		   // 方法二：直接解除值传递
    			return false;
            });
  </script>
```

（3）默认行为：网页中的元素有自己的默认行为,例如单击超链接后会跳转,点击提交表单按钮会提交

（4）阻止默认行为：可以使用==event.preventDefault();==方法阻止事件默认行为方法

例如：a标签的跳转

```html
<script>
        $(function () {
            $("a").click(function (event) {
                var str = $("a").attr("href");
                // 如果超链接是百度就不跳转
                if(str.indexOf("baidu") > 0){
                    // 阻止默认行为
                    event.preventDefault();
                }
            });
            //方法二：
            return false;
        });
</script>
```

##### 6.4自动触发事件

------

（1）通过代码控制事件, 不用人为点击/移入/移除等事件就能被触发。

==trigger==("eventName"): #触发事件的同时会触发事件冒泡  #触发事件的同时会触发事件默认行为；

（2）triggerHandler("eventName")：#触发事件的同时不会触发事件冒泡  #触发事件的同时不会触发事件默认行为

<script>
    // trigger会触发系统默认事件
           $("input[type='submit']").trigger("click");
            // triggerHandler不会触发系统默认事件
            $("input[type='submit']").triggerHandler("click");
</script>

（3）注意点

==a标签==：用了自动触发的事件并且触发a的默认行为，不能直接使用$("a")，而是要在a标签中添加一个span标签,触发span标签，如：("span").trigger("click");

##### 6.5自定义事件

------

（1）自定义事件就是自己起一个不存在的事件名称来注册事件, 然后通过这个名称还能触发对应的方法执行, 这就是传说中的自定义事件。

（2）自定义事件的前提条件

- 1.事件必须是通过on绑定的

- 2.事件必须通过trigger来触发

- 因为trigger方法可以自动触发对应名称的事件,所以只要事件的名称和传递给trigger的名称一致就能执行对应的事件方法

  <script>
       $(".father").on("njClick", function () {
                 alert("njClick");
             });
       $(".father").trigger("njClick");
  </script>

##### 6.6事件命名空间

------

（1）事件命名空间主要用于区分相同类型的事件,区分不同前提条件下到底应该触发哪个人编写的事件

（2）格式: "eventName.命名空间"

（3）添加事件命名空间的前提条件

- 事件是通过on来绑定的
- 通过trigger触发事件

==注意点==(面试题!!!面试题!!!面试题!!!):

- 不带命名空间事件被trigger调用,会触发带命名空间事件
- 带命名空间事件被trigger调用,只会触发带命名空间事件
- 下级不带命名空间事件被trigger调用,会冒泡触发上级不带命名空间和带命名空间事件
- 下级带命名空间事件被trigger调用,事件只会冒泡到带相同命名空间的上级元素

<script>
     // 给父元素添加带命名空间事件
            $(".father").on("click.66", function () {
                alert("66 - father");
            });
</script>

##### 6.7事件委托

------

（1）格式:$(parentSelector).delegate(childrenSelector, eventName, callback)

```html
 //方法一：$("ul").on("click","li",function () {}
<script>
    // 1.委托ul监听li的点击事件，方法二
        $("ul").delegate("li","click",function () {
            // 这里的this之所以是触发事件的li,本质是因为"事件冒泡", 触发事件的li向上传递到ul,触发了click事件.
           console.log(this);
            // 弹出当前点击行内容
            alert($(this).html());
</script>
```
##### 6.8鼠标移入移除事件

------

（1）mouseenter和mouseleave：移动到子元素***不会\***触发事件

（2）mouseover和mouseout：移动到子元素***会\***触发事件

（3）hover()：内容监听移入和移出；内部实现就是调用mouseenter和mouseleave

例如：

<script>
    // 传入两个回调函数,一个监听移入,一个监听移出
            $(".father").hover(function () {
                console.log("mouseenter");
            }, function () {
                console.log("mouseleave");
            });
            */
            // 如果只传入一个方式,那么这个方式既监听移入也监听移出
            $(".father").hover(function () {
                console.log("移入移除");
            });
</script>
#### 7.动画

##### 7.1显示与隐藏与切换

------

（1）==show==(ms,fu)：显示动画，内部实现原理根据当前操作的元素是块级还是行内决定, 块级内部调用display:block;,行内内部调用display:inline;

<script>
    // 注意: 这里的时间是毫秒
    $("div").show(1000, function () {
        // 作用: 动画执行完毕之后调用
        alert("显示动画执行完毕");
    });
</script>

（2）==hide==(ms,[fu])：隐藏动画，第一个参数单位是毫秒, 1000毫秒等于1秒，默认的动画时长是400毫秒

<script>
     $("div").hide(1000, function () {
        alert("隐藏动画执行完毕");
    });
</script>

（3）==toggle==([spe],[eas],[fu])：切换动画(显示变隐藏,隐藏变显示)

<script>
    $("div").toggle(1000, function () {
        alert("切换动画执行完毕");
    });
</script>
##### 7.2获取网页滚动值

------

 ==$("html,body").scrollTop()==；

##### 7.3展开和收起动画

------

（1）slideDown([s],[e],[fn])：展开动画； 参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已

<script>
    $("button").eq(0).click(function () {
    $("div").slideDown(1000, function () {
        alert("展开完毕");
    });
});
</script>

（2）slideUp([s],[e],[fn])：收起动画；

例如：

<script>
    $("button").eq(1).click(function () {
    $("div").slideUp(1000, function () {
        alert("收起完毕");
    });
});
</script>

(3) slideToggle([s],[e],[fn])

例如：

<script>
    $("button").eq(2).click(function () {
    $("div").slideToggle(1000, function () {
        alert("收起完毕");
    });
});
</script>

##### 7.4暂停动画

------

==注意：==

（1）在Jquery中如果需要执行动画操作，建议现在执行动画之前先调用==stop==方法，然后再执行动画。

例如：

<script>
    var $sub=$(this).children(".sub");
    //停止当前动画
    $sub.stop();
    //执行动画
    $sub.slideDown(1000);
</script>
（2）stop([c],[j])：停止指定元素上正在执行的动画

<script>
   // 立即停止当前和后续所有的动画
		$("div").stop(true);
		$("div").stop(true, false);
    // 立即完成当前的, 继续执行后续动画
 		$("div").stop(false, true);
	// 立即完成当前的, 并且停止后续所有的
		$("div").stop(true, true);
</script>

##### 7.5淡入淡出动画

------

（1）==淡入动画==：fadeln([s],[e],[fn]): 参数、注意事项和显示隐藏动画一模一样, 只不过动画效果不一样而已

<script>
    $("button").eq(0).click(function () {
    $("div").fadeIn(1000, function () {
        alert("淡入完毕");
    });
});
</script>

(2) 淡出动画：fadeOut([s],[e],[fn])

(3) 切换动画：fadeToggle([s],[e],[fn]): 切换动画(显示变淡出,不显示变淡入)

(4) 淡入到指定透明度动画：fadeTo([s],o,[e],[fn)

​		#可以通过第二个参数,淡入到指定==的透明度==(取值范围0~1)

##### 7.6自定义动画

------

（1）animate(p,[s],[e],[fn])

<script>
    /*
第一个参数: 接收一个对象, 可以在对象中修改属性
第二个参数: 指定动画时长
第三个参数: 指定动画节奏, 默认就是swing:先慢后快再慢，linear：匀速
第四个参数: 动画执行完毕之后的回调函数
*/
$(".two").animate({ //同时操作多个属性，自定义动画会同步执行
    marginLeft: 500;
    //如果想在上一次位置或者状态下再次进行动画就可以累加动画
    width:"+=100";
    }, 5000, "linear", function () {
    //alert("自定义动画执行完毕");
});

##### 7.7动画队列

------

（1）多个动画方法链式编程,会等到前面的动画执行完毕再依次执行后续动画,但是如果后面紧跟一个非动画方法则会被立即执行，再执行动画方法

例如：

```html
	<script>
	    $("div").slideDown(1000).slideUp(1000).show(1000);
	</script>
```
==注意：==

- 动画队列方法queue()后面不能继续直接添加==queue()==

- 如果想继续添加必须在上一个queue()方法中==next()==方法

  <script>
      $(".one").slideDown(1000).slideUp(1000).show(1000).queue(function (next) {
      $(".one").css("background", "yellow");
      next(); // 关键点
  }).queue(function () {
      $(".one").css("width", "500px")
  });
  </script>

##### 7.8延时动画

------

(1) delay(d,[q])：设置动画延迟时长,前一个动画执行完后，延时多久，后一个动画开始执行

		<script>
		    $(".one").animate({
				width: 500
				// height: 500
			}, 1000).delay(2000).animate({
				height: 500
			}, 1000);
		</script>

#### 8.文档处理

##### 8.1节点插入

------

（1）内部插入：==append()==  元素添加到指定元素内部的最后

appendTo(): 同理，表达方式不一样

```html
<script>
    // 1.创建一个节点
		var $li = $("<li>新增的li</li>");
	// 2.添加节点
	 	$("ul").append($li);
	// $li.appendTo("ul");
</script>
```
(2)	==prepend()==：元素添加到指定元素内部的最前面；prependTo()

<script>
    // 1.创建一个节点
		var $li = $("<li>新增的li</li>");
	// 2.添加节点
		$("ul").prepend($li);
	//  $li.prependTo("ul");
</script>

(3)外部插入：将元素添加到指定元素外部的后面；==after();== insertAfter()

​					  将元素添加到指定元素外部的前面：==before()==; insertBefore()

##### 8.2节点删除

------

（1） empty() ;删除指定==元素的内容和子元素==, 指定元素自身不会被删除

（2）==remove()==：删除指定元素

```html
	<script>
	    // 删除所有div
			$("div").remove();
		// 删除div中id是box1的那个div
			$("div").remove("#box1");
	</script>
```
（3）detach()：删除指定元素；用法跟remove相同

（4）两者的区别：

​		remove删除元素后,元素上的事件会被移出; detach删除元素后,元素上的事件会被保留

##### 8.3替换节点

------

(1) ==replaceWith()==： 将所有匹配的元素替换成指定的HTML或DOM元素

(2)  replaceAll() : 将匹配的元素替换掉所有 selector匹配到的元素

```html
	<script>
	    var $item = $("<h6>我是标题6</h6>");
			// 利用新的节点替换旧的节点
			$("h1").replaceWith($item);
			//$item.replaceAll("h1");
	</script>
```
##### 8.4复制节点

------

(1) 复制节点：==clone()==  :浅复制不会复制节点的事件 ； 深复制会复制节点的事件

```html
	<script>
	    // 1.浅复制一个元素
    		var $li = $("li:first").clone(false);
    	// 2.将复制的元素添加到ul中
    		$("ul").append($li); // 点击li无法响应事件
	</script>
```
<script>
    // 1.深复制一个元素
        var $li = $("li:first").clone(true);
        // 2.将复制的元素添加到ul中
        $("ul").append($li); // 点击li可以响应事件
</script>

#### 9 注意点

------

//监听==内容的实时输入==通过事件委托（动态创建）：

<script>
    $("body").delegate(".comment","propertychange input",function(){
		console.log($(this).val); //获得实时input输入框或者Ttextarea的值
    });
</script>

//数组==转化为字符串==

arr.join("");

#### 10Jquery的基本结构

------

（1）Jquery本质就是一个闭包，为了避免多个框架冲突。

（2）window.xxx=xxx来让外界访问。

（3）Jquery为什么要给自己传window参数（为了方便压缩代码（为了提升查找效率）

（4）Ie9以下的undefined可以被修改，为了保证内部使用的undefined不被修改，所以需要接收一个正确的undefined.

<script>
    function fun(){
       var num =10;
       window.num=num;
    };
    fun();
    //等价于
    (function fun(){
        var num =10;
        window.num=num;
    })();
</script>

##### 10.1入口函数测试

（1）传入数组：会将数组中的所有元素依次存入到Jquery对象中.

（2）传入 ‘’ null, undefined, NaN,0 false,返回空的Jquery对象

（3）字符串：代码片段：会将创建好的Dom元素存储到Jquery对象中返回；

##### 10.2Jquery编写

<script>
    (function (window, undefined){
        //传入selector参数并执行回调函数
        var njQuery=function(selector){
            return new njQuery.prototype.init(selector);
        }
        njQuery.prototype={
            constructor:njQuery
            //调用执行init
            init:function(selector){
                //去除字符串两端的空格
                selector = njQuery.trim(selector);
                //1.传入 ‘’ null, undefined, NaN,0 false,返回空的Jquery对象
                if(!selector){
                    return this;
                }
                //2.方法处理
                else if(njQuery.isFunction(selector)){
                        }
        //3.字符串
        else if(njQuery.isString(selector)){
            //判断是否是代码片段
            if(njQuery.isHTML(selector)){
                //根据代码片段创建所有的元素
                var temp = document.creatElement("div");
                temp.innerHTML = selector;
               /*
                //将创建好的一级元素添加到Jquery中
                for(var i=0;i<temp.children.length;i++){
                    this[i]=temp.children[i];
                }
                //给jQuery对象添加到length属性
                this.length=temp.children.length;*/
                //将上面*里面的内容压缩
                [].push.apply(this,temp.children);
                //此时此刻的this是njquery对象，返回加工好的this(jQuery)
               //eturn this;
            }
            //判断是否是标签，选择器
            else{
                //根据传入的选择器找到对应的元素
                var res= document.querySelectorAll(selector);
                //将找到的元素添加到nJquery中
                [].push.apply(this,res);
                //返回加工的this
               //eturn this;
            }
          }
        //3.数组
       /* else if(typeof selector === "object" && "length" in selector && selector != window)*/
        else if(njQuery.isArray(selector)){
           //真数组
            if(({}).toString.apply(selector) === "{object Array}"){
                [].push.apply(this,selector);
               //eturn this;
            }
           //伪数组
            else{
                //将自定义的伪数组转换为真数组
                var arr =[].slice.call(selector);
                //将真数组转换为伪数组
                [].push.apply(this, arr);
              //return this;
            }
        }
        //上述类型以外
        else{
            this[0] = selector;
            this.length=1;
           //return this;
    return this;
    };
    //编写方法判断是字符串
 	njQuery.isString = function(str){
    	return typeof str === "string";
};
	//编写方法判断是代码段
	njQuery.isHTML = function(str){
        return str.charAt(0) == '<'&& selector.charAt(selector.length-1)==">" && selector.length>=3
    };
	//编写方法去掉前后空格
	njQuery.trim=function(str){
        //判断是不是字符串
        if(!njQuery.isString(str)){
            return str;
        }
        //判断是否支持trim方法
        if(str.trim){
            return str.trim();
    }else{
        //去掉前后的空格
        return str.replace(/\s+|\n+$/g,"");
    }
    //编写方法判断是不是对象，是不是数组，是不是window
    njQuery.isObject = function(sele){
        return typeof sele === "object";
    }
    //是不是window
    njQuery.isWindow = function(sele){
        return sele === window;
    }
    //是不是数组
    njQuery.isArray = function(sele){
        if(njQuery.isObject(sele) && !njQuery.isWindow(sele) && "length" in sele){
            return true;
        }
        return false;
    }
    //是不是方法
    njQuery.isFunction=function(sele){
        return typeof sele === "function";
    }    
    njQuery.prototype.init.prototype=njQuery.prototype;
    window.njQuery=window.$=njQuery;
})(window);
</script>

##### 10.3apply和call方法

（1）专门用来修改方法内部的this.

（2）通过apply(obj)将找到的test方法内部的this修改为自定义的; 将数组中的元素依次取出，传递给形参。

（3）call(对象，参数1，参数2，....);

（4）apply(对象，数组[])

例如：

```html
         <script>
             //真数组-->伪数组
             var arr=[1,3,5,7,9,10];
             var obj={};
             
             //通过apply方法传入到对象里面
             [].push.apply(obj,arr);
             consle.log(obj);
         </script>
```
（5）因为浏览器兼容的问题，ie8以下的浏览器版本 apply方法没法直接用于伪数组---》真数组

​		系统自带的伪数组倒可以

```html
	<script>
        //系统自带的
	    var res = document.querySelectorAll("div");
	</script>
```
```html
      	<script>
            //自定义伪数组
            var obj = {0:"lnj",1:"33",length:2};
      	    //如果真想将伪数组转换为真数组
            var arr=[].slice.call(obj);
            console.log(arr);
      	</script>
```
##### 10.4选择器处理

（1）上面代码中。。

##### 10.5 extend方法

<script>
    njQuery.extend = njQuery.prototype.extend = function(obj){
        //console.log(this);
        for(var key in obj){
            this[key] = obj[key]
        }
    }
</script>

##### 10.6状态表

(1)document.readyState:属性有如下状态：

​	uninitialized ---还未开始载入  loading--载入中

​	interactive --已加载，文档与用户可以开始交互   complete --- 载入完成

==onreadystatechange==：事件就是专门用于监听document.readState属性的改变的

<script>
    //兼容ie8以下的浏览器
    document.attachEvent("onreadystatechange",function(){
        })
</script>

##### 10.7jQuery上的核心方法和属性

（1）jQuery 获取jq版本号

（2）selector 实例默认的选择器取值

（3）length:实例默认长度

（4）push:给实例添加新元素

（5）sort：对实例中的元素排序

（6）splice:按照指定的下标指定数量删除元素，也可以替换删除的元素

（7）toArray：把实例转换为数组返回。

（8）get：如果不传递参数，将和toArray一样； 获取指定下标的元素，获取原生Dom

### Ajax

#### 1.服务器安装

（1）服务器也是电脑，24小时不断电，不关机的电脑，Web服务器

（2）Web服务器相关软件，例如：Apache,Tomcat,Node.js等

（3）安装WAMPServer软件：W：windows操作系统，A：Apache:服务器软件

​			MySQL开源免费数据库，PHP：超文本预处理器，直接将代码嵌入HTML文档中执行。

#### 2.PHP语法

##### 2.1.格式

```php
<?php   
    ?>
```
##### 2.2定义变量

例如：$num=10;(只能由数字字母下划线开头)；

##### 2.3打印

例如：echo $num; （echo+空格+要打印的数据);==不能打印对象和数组==

注意点：后端编写的代码不能直接运行，只能放到服务器对应的文件夹下运行

//如何通过服务器运行：通过ip地址找到服务器对应的文件夹，然后再找到对应的文件运行。

##### 2.4php中定义集合

(1)数组：$arr=array[1,2,3];   ==打印==： print_r(）；

(2)对象：$diet = array("name"=>"lnj", "age"=>"13");   ==打印==： print_r(）；值：echo  ￥diet["name"]；

##### 2.5分支循环

if /switch /三目 /for /while (跟Js一样)；==长度==：count($arr);

#### 3.请求的处理

（1）如果是get请求会将提交的数据拼接到URL的后面 ？userName=Inj&userpassword=123456

（2）如果是post请求会将提交的数据放到请求头中;

（3）GET请求对提交的数据大小有限制；POST请求对数据大小没有限制

（4）运用场景：

​		GET请求用于提交非敏感数据和小数据。

​		POST请求用于提交给敏感数据和大数据。

##### 3.1文件上传

（1）上传文件一般使用POST提交

（2）上传文件必须设置enctype="muliipart/form-data"

（3）上传的文件再PHP中可以通过$_FILES获取

（4）PHP中文件会默认上传一个目录，接收完毕之后会自动删除。

（5）大文件上传：找到WAMP的bin-->apache-->bin

​		![image-20201111092158614](E:\扬州前端\学习笔记图片缓存区\image-20201111092158614.png)

#### 4.Ajax

（1）AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况。

（2）异步的 JavaScript 和 XML；

##### 4.1步骤：

（1）创建一个异步对象

（2）设置请求方式和请求地址

（3）发送请求

（4）监听状态变化

（5）处理返回的结果

 <script>
        // 获取
        var but = document.querySelector("button");
        // 添加按钮事件
        but.onclick = function (ev1) {
            //1.创建一个异步对象
            var xmlhttp = new XMLHttpRequest();
            //2.设置请求参数和请求地址
            // 规定请求的类型、 URL 以及是否异步处理请求。
            // method： 请求的类型； GET 或 POST
            // url： 文件在服务器上的位置
            // async： true（ 异步）
            xmlhttp.open("GET", "./index1.php", true);
            //3.发送请求
            xmlhttp.send();
            //4.监听状态变化
            xmlhttp.onreadystatechange = function (ev2) {
                //存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
                // 0: 请求未初始化
                // 1: 服务器连接已建立
                // 2: 请求已接收
                // 3: 请求处理中
                // 4: 请求已完成， 且响应已就绪
                if (xmlhttp.readyState == 4) {
                    // 200: "OK"
                    // 404: 未找到页面
                    if(xmlhttp.status>=200 && xmlhttp.status<300 || xmlhttp.status===304){
                        //5. 返回处理的结果
                        console.log(xmlhttp.responseText);
                    }else{
                        console.log("没有接受服务器返回的数据");
                    }
                }
           }
    }
</script>

##### 4.2兼容性

==注意==：

（1）所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）

（2）在IE浏览器中，如果通过Ajax发送GET请求，那么IE浏览器同一个URL只有一个结果。

​		ie缓存：解决方法：不断的改变地址：Math.random() / new Date().getTime()

​		xhr.open("GET","05-AJAX.txt?t="+(new Date().getTime()),true);

##### 4.3封装ajax的GET方法

<script>
    //转换字符串
    function obj2str(obj){
       /* {
            "username":"inj",
            "userpwd":"123456",
            "t":"3714414114"
        }*/
        //动态添加属性
        obj.t=new Date().getTime();
        var res=[];
        for(var key in obj){
            //url不可以出现中文的，只能出现字母/数字/下划线/ASCll码
            //通过encodeURIComponent把中文转化为特殊字符串
            res.push(encodeURIComponent(key)+"="+encodeURIComponent(obj[key])); //[username=inj,userpwd=123456];
        }
        return res.join("&");//username=inj&userpwd=123456
    }
    function ajax(type,url,obj,timeout,success,error){
        //0.将对象转换为字符串
        	var str = obj2str(obj); //?key=value&key=value
        //1.创建一个异步对象
        	var xmlhttp;
        //定义时间
        	var timer;
        	if(window.XMLHttpRequest){
                xmlhttp = new XMLHttpRequest();
            }else{
                //兼容IE
                xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
            }
            //2.设置请求参数和请求地址
        	if(type.toLowerCase() == "get"){
                 xmlhttp.open(type, url+"?"+str, true);
            	//3.发送请求
            	 xmlhttp.send();
            }else{
                xmlhttp.open(type,url,true);
				xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
				xmlhttp.send(str);
            }
            //4.监听状态变化
            xmlhttp.onreadystatechange = function (ev2) {
                //存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
                if (xmlhttp.readyState == 4) {
                    //清除一下定时器
                    clearInterval(timer);
                    // 200: "OK"
                    // 404: 未找到页面
                    if(xmlhttp.status>=200 && xmlhttp.status<300 || xmlhttp.status===304){
                        //5. 返回处理的结果
                        // console.log(xmlhttp.responseText);
                        success(xmlhttp);
                    }else{
                        //console.log("没有接受服务器返回的数据");
                        error(xmlhttp);
                    }
                }
           }
        //判断外界是否传入了超时时间
        if(timeout){
            //开启定时器
            timer=setInterval(function(){
                //超时终止
                xmlhttp.abort();
                //清除
                clearInterval(timer);
            },timeout)
        }
    }
</script>

##### 4.4ajax处理方法之POST

(1）注意：如果需要像 HTML 表单那样 POST 数据，请==使用== setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：

<script>
    xmlhttp.open("POST","ajax_test.asp",true);
	xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
	xmlhttp.send("fname=Bill&lname=Gates");
</script>

##### 4.5jQuery处理ajax

<script>
    $.ajax({
        type: "POST",
        url: "./index1.php",
        data: "username=John&userpwd=123456",
        success: function(msg){
            alert( "Data Saved: " + msg ); 
        }
});
</script>

##### 4.6XML

（1）固定格式：头标签 ，根标签可以随时设定

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<person>
	<name>  杨青松 </name>
	<age>18</age>
</person>
```

（2）php调用xml

```php
<?php    
  //执行结果有中文，必须在php文件顶部设置
  header("content-type:text/xml; charset=utf-8");
  // 请求xml的数据表示
  echo file_get_contents("index2.xml");     
?>
```

##### 4.7JSON

（1）文本文档：.txt的格式 ;

```json
	{
		"name":"inj",
		"age":"33"
	}
```

（2）PHP请求：

```php
<?php    
  // 请求xml的数据表示
  echo file_get_contents("index2.txt");     
?>
```

 （3）==注意==1.

在低版本的IE中，不可以使用原生的JSON.parse()方式，但是可以使用json2.js这个框架来兼容

可以在gitHub上下载。

（4）==注意2：==

非标准的JSON字符串：{error:0 ,id : 1; time:123456, acc:0 , ref: 0}

标准格式的：{"name":“yqs”,"age":"18 "}

标准格式转化为JS对象：==JSON.parse()方法==，但非标准的不行，会报错

VM179:Uncaught SyntaxErarror:Unexpexted token e in JSON at position

==非标准转化为js对象==：==eval("("+msg+")");==  标准的也能用。

例如：![image-20201112102822471](E:\扬州前端\学习笔记图片缓存区\image-20201112102822471.png)

##### 		4.8Cookie

（1）cookie：会话跟踪技术  客户端 ：将网页中的数据保存在浏览器中，cookie默认不会保存任何数据。

（1）cookie的生命周期：

​			默认情况下生命周期是一次会话（浏览器被关闭）

​			如果通过expires=设置了过期时间，并且过期时间没有过期，那么下次打开浏览器还是存在

​			如果通过expires=设置了过期时间，并且过期时间已经过期，那么立即删除保存的数据。

（2）session：会话跟踪技术	服务端

（3）存储：

```javascript
var date = new Date();
date.setDate(date.getDate()+1);
//时间设置到明天
doucument.cookie= "age=12; expires="+date.toGMTString()+":"";
```

（4）cookie不能一次性设置多条数据，要想保存多条数据，只能一条一条的设置。

（5）cookie有大小和个数限制，个数：20-50；大小：4kB左右。

（6）作用范围：同一个浏览器同一个路径下访问

（7）如果说保存到了本路径下，我们现在在==下一级==目录访问，或者在==上一路径==访问

​		需要设置：document.cookie = "name=zs; path=/;"; 保存到==根路径==下

（8）如果我们在www.it666.com下保存了个cookie,那么我们在edu.it666.com下是无法访问的

​		如果要要操作：document.cookie="name=zs;path=/; ==domain===it666.com";

##### 4.9Hash

(1)保存，刷新过后也会停留在当前页面，转给其他浏览器也会保存当时的保存地址。

<script>
    //创建一个hash值
    window.location.hash=3;
    //获取hash值
    console.log(window.location.hash.substring(1));
</script>